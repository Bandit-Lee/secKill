# 🔊SecKill
一个秒杀的案例，提供一个解决方案
## 解决方案
- 分布式Session(Spring session/Spring data redis)
  - 用户登录
  - 共享session
- 秒杀
  1. 超卖处理
     1. 生成订单放入缓存, 去缓存中查是否有订单。SQL唯一索引，开启事务后update行级锁，或者使用乐观锁版本号控制，或者redis、zk分布式锁
     2. 数据库压力大、引入消息队列RabbitMQ
     3. redis预减库存(预热)、开始前先把商品放进redis、在缓存中减完之后走消息队列异步更新数据库，先返回给前端一个排队中的状态
  2. 安全处理
     1. 接口隐藏：秒杀的接口先不暴露出来，用户点秒杀会生成一个随机的地址，请求源地址拼接这个随机地址的url
     2. 验证码：秒杀前用验证码，过滤掉一些用脚本抢的用户
     3. 接口限流：对用户一直点点多了返回繁忙：放redis一个很短的key，5s这样点多了直接返回报错，漏桶算法/令牌桶算法
  
## 压测
### 普通查询接口压测
```text
* ============== 优化前 =================================
* windows   : 1000线程 * 10 QPS：1000 5000 * 1 QPS：800
* linux1核2g: 1000线程 * 10 崩了       5000 * 1 QPS：50
* =========================================================
*
* ============== 第一次优化 页面缓存 =========================
* windows  : 1000线程 * 10 QPS：2790 5000 * 1 QPS：1600 QPS直接翻了两倍
```

### 秒杀接口压测
```text
* ===================== 未优化前================ <br>
* Windows 1000线程 * 10 QPS：30.3 限制50个 卖出497个  5000 * 1 QPS: 28.7 <br>
* ===================== 订单缓存优化/SQL加唯一索引后 ============== <br>
* Windows 1000线程 * 10 QPS：895   (超卖解决)   5000 * 1 QPS: 400 <br>
* ===================== redis预减库存、本地缓存减少redis通信，消息队列处理 订单
* Windows 1000线程 * 10 QPS：3100  (超卖解决)   5000 * 1 QPS: 1000 <br>
```
